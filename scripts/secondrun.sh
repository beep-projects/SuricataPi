#!/bin/bash
#
# Copyright (c) 2021, The beep-projects contributors
# this file originated from https://github.com/beep-projects
# Do not remove the lines above.
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see https://www.gnu.org/licenses/
#
# This file is inspired by the firstrun.sh, generated by the Raspberry Pi Imager https://www.raspberrypi.org/software/
#
# This file will be called after the network has been configured by firstrun.sh
# It updates the system, installs motioneye and configures all attached USB cameras
# It also sets up telegram.bot as command interface and activates people detection using OpenCV for the camera images
# This script downloads a lot of stuff, so it will take a while to run
# For a full description see https://github.com/beep-projects/suricata/readme.md
#


#######################################
# Checks if any user is holding one of the various lock files used by apt
# and waits until they become available. 
# Warning, you might get stuck forever in here
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function waitForApt() {
  while sudo fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1; do
   echo ["$(date +%T)"] waiting for access to apt lock files ...
   sleep 1
  done
}

#######################################
# Checks if internet can be accessed
# and waits until it becomes available. 
# Warning, you might get stuck forever in here
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function waitForInternet() {
  until nc -zw1 google.com 443 >/dev/null 2>&1;  do
    #newer Raspberry Pi OS versions do not have nc preinstalled, but wget is still there
    if wget -q --spider http://google.com; then
      break # we are online
    else
      #we are still offline
      echo ["$(date +%T)"] waiting for internet access ...
      sleep 1
    fi
  done
}

# redirect output to 'secondrun.log':
exec 3>&1 4>&2
trap 'exec 2>&4 1>&3' 0 1 2 3
exec 1>/boot/secondrun.log 2>&1

echo "START secondrun.sh"
# the following variables should be set by firstrun.sh
BOT_TOKEN=COPY_BOT_TOKEN_HERE
HOME_NET=COPY_HOME_NET_HERE
ENABLE_RASPAP=false
# fixed configs
#SERVICE_FOLDER=/etc/systemd/system
#CONDOCAM_FOLDER=/etc/condocam
#CONDOCAM_IMAGE_FOLDER=/var/log/condocam/images
#CONDOCAMBOT_CONF="${CONDOCAM_FOLDER}/condocambot.conf"
#PROTOTXT="MobileNetSSD_deploy.prototxt.txt"
#CAFFEEMODEL="MobileNetSSD_deploy.caffemodel"
# check the arch, as armv6l systems are not properly supported
ARCH=$(arch)

#echo "create required directories"
#echo "mkdir -p ${CONDOCAM_FOLDER}"
#sudo mkdir -p "${CONDOCAM_FOLDER}"
#echo "mkdir -p ${CONDOCAM_IMAGE_FOLDER}"
#sudo mkdir -p "${CONDOCAM_IMAGE_FOLDER}"

# internet connectivity is required for installing required packages and updating the system
waitForInternet

# first we setup telegram, so we can send status messages to the user
echo "installing utilities missing in Raspberry OS, but needed by this script"
waitForApt
echo "I am now setting up the telegram communication"
# get latest telegram.bot from https://github.com/beep-projects/telegram.bot
wget https://github.com/beep-projects/telegram.bot/releases/latest/download/telegram.bot
chmod 755 telegram.bot
sudo ./telegram.bot --install

#echo "configuring telegram bot"
#echo "telegram.bot --get_updates --bottoken ${BOT_TOKEN}"
# for this call to be successfull, there must be one new message in the bot chat, not older than 24h
#UPDATEJSON=$( telegram.bot --get_updates --bottoken ${BOT_TOKEN} )
#echo "${UPDATEJSON}"
#get the information for the condocambot.conf
#LAST_UPDATE_ID=$( echo "${UPDATEJSON}" | jq '.result | .[0].update_id' )
# get the client_id for sending the messages to the created telegram bot
#UPDATE_TYPE="message"
#if [[ $( echo "${UPDATEJSON}" | jq '.result | .[0].message' ) = "null" ]]; then
#  UPDATE_TYPE="my_chat_member"
#fi

#CHAT_ID=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.chat.id" )
# note, the condocambot is not very picky, the sender of the first message it sees, will be the owner
#ADMIN_ID=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.id" )
#ADMIN_IS_BOT=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.is_bot" )
#ADMIN_FIRST_NAME=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.first_name" )
#ADMIN_LANGUAGE_CODE=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.language_code" )

#telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --success --text "telegram.bot is installed successfully, continuing to install the rest of the system."

#if [[ "${ARCH}" == "armv6l" ]]; then
#	telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --warning --text "You are trying to run **condocam.ai** on an **armv6l** based system, which is **not** properly supported.\n
#	Installation will continue, but **people detection** will not be enabled, because **OpenCV** has no packages available for this system and you might experience problems with **Motion** itself.\n
#	If you know how to fix these issue, please contribute to the project."
#fi

# now we want to update the system and install packages
echo "updating the system"
waitForApt
sudo apt update
waitForApt
sudo apt full-upgrade -y
# fail2ban is added to add some security to the system. Remove it, if you don't like it
waitForApt
echo "sudo apt install -y fail2ban"
sudo apt install -y fail2ban

# write the condocambot.conf file
#echo
#echo "write the condocambot.conf file"
#echo "BOT_TOKEN=${BOT_TOKEN}" | sudo tee "${CONDOCAMBOT_CONF}" #this call creates the file, the others append to it
#echo "LAST_UPDATE_ID=${LAST_UPDATE_ID}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "CHAT_ID=${CHAT_ID}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_ID=${ADMIN_ID}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_IS_BOT=${ADMIN_IS_BOT}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_FIRST_NAME=${ADMIN_FIRST_NAME}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_LANGUAGE_CODE=${ADMIN_LANGUAGE_CODE}" | sudo tee -a "${CONDOCAMBOT_CONF}"
# make sure that the condocambot.sh is using the created conf file
#sudo sed -i "s/^CONF_FILE=.*/CONF_FILE=${CONDOCAMBOT_CONF//\//\\/}/" /boot/files/condocambot.sh
#sudo sed -i "s/^CONDOCAM_IMAGE_FOLDER=.*/CONDOCAM_IMAGE_FOLDER=${CONDOCAM_IMAGE_FOLDER//\//\\/}/" /boot/files/condocambot.sh

#telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --success --text "system is apt updated, next step is to install motion and motionEye"

# just follow the guide on https://suricata.readthedocs.io/en/latest/install.html to install suricata

# install suricata all dependencies
echo "installing suricata and all dependencies"
sudo apt install -y suricata
#make sure suricata is not running
sudo systemctl stop suricata

# update rules
sudo suricata-update
# add a cron job to update the rules daily
#write out current crontab
sudo crontab -l > tmp_crontab
#echo new cronjob into cron file
echo "3 3 * * * suricata-update" >> tmp_crontab
#install new cron file
sudo crontab tmp_crontab
sudo rm tmp_crontab

#enable log rotate
#/etc/logrotate.d/suricata
#/var/log/suricata/*.log /var/log/suricata/*.json
#{
#    daily
#    maxsize 1G
#    rotate 7
#    missingok
#    nocompress
#    create
#    sharedscripts
#    postrotate
#        systemctl restart suricata.service
#    endscript
#}

sudo systemctl start suricata


#configure suricata
#sudo vi /etc/suricata/suricata.yaml
#HOME_NET: "[192.168.0.0/16,10.0.0.0/8,172.16.0.0/12]"
sudo sed -i "s/^HOME_NET=.*/HOME_NET: \"\[${HOME_NET}\]\"}/" /etc/suricata/suricata.yaml

if $ENABLE_RASPAP; then
  #install raspap
  telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --warning --text "I am installing now RaspAP, remember to secure this system after the setup is finished!"
  curl -sL https://install.raspap.com | bash -s -- --yes
fi

#telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --success --text "All packages are installed now, I am just doing some clean up and then I will be available for you at http://${HOSTNAME}:8765"

echo "remove autoinstalled packages" 
waitForApt
echo "sudo apt -y autoremove"
sudo apt -y autoremove

echo "add run /boot/thirdrun.sh command to cmdline.txt file for next reboot"
sudo sed -i '$s|$| systemd.run=/boot/thirdrun.sh systemd.run_success_action=reboot systemd.unit=kernel-command-line.target\n|' /boot/cmdline.txt

#disable the service that started this script
sudo systemctl disable secondrun.service
echo "DONE secondrun.sh, rebooting the system"

sleep 2
sudo reboot
