#!/bin/bash
#
# Copyright (c) 2021-2024, The beep-projects contributors
# this file originated from https://github.com/beep-projects
# Do not remove the lines above.
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see https://www.gnu.org/licenses/
#
# This file is inspired by the firstrun.sh, generated by the Raspberry Pi Imager https://www.raspberrypi.org/software/
#
# This file will be called after the network has been configured by firstrun.sh
# It updates the system, installs suricata, elasticsearch, logstash and kibana,
# This script downloads and configures a lot of stuff, so it will take a while to run
# For a full description see https://github.com/beep-projects/SuricataPi/readme.md
#


#######################################
# Checks if any user is holding one of the various lock files used by apt
# and waits until they become available. 
# Warning, you might get stuck forever in here
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function waitForApt() {
  while sudo fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1; do
   echo ["$(date +%T)"] waiting for access to apt lock files ...
   sleep 1
  done
}

#######################################
# Checks if internet can be accessed
# and waits until it becomes available. 
# Warning, you might get stuck forever in here
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function waitForInternet() {
  until curl --output /dev/null --silent --head --fail http://www.google.com; do
    echo ["$(date +%T)"] waiting for internet access ...
    sleep 1
  done
}

#######################################
# Print error message.
# Globals:
#   None
# Arguments:
#   $1 = Error message
#   $2 = return code (optional, default 1)
# Outputs:
#   Prints an error message to stderr
#######################################
function error() {
    printf "%s\n" "${1}" >&2 ## Send message to stderr.
    exit "${2-1}" ## Return a code specified by $2, or 1 by default.
}

#######################################
# Download sources, check integrity and extract
# Globals:
#   None
# Arguments:
#   $1 = URL of the tar.gz file
#   $2 = URL of the tar.gz.asc file holding the gpg signature
#   $3 = source directory used as target
#   $4 = name of the utility for which the source is downloaded
# Outputs:
#   extracts the source to $3 or exits with error message
#######################################
function getSources() {
  local SOURCE_URL=${1}
  local SIGNATURE_URL=${2}
  local SOURCE_DIR=${3}
  local NAME=${4}
  echo "Get sources for $NAME into $SOURCE_DIR"
  # Downloading the openvas-scanner sources
  curl -f -L "$SOURCE_URL" -o "$SOURCE_DIR/$NAME.tar.gz"
  curl -f -L "$SIGNATURE_URL" -o "$SOURCE_DIR/$NAME.tar.gz.asc"
  # Verifying the source file
  
  if ! gpg --verify "$SOURCE_DIR/$NAME.tar.gz.asc" "$SOURCE_DIR/$NAME.tar.gz";then
    error "Integrity check for $SOURCE_DIR/$NAME.tar.gz failed, exit" 
  fi
  # If the signature is valid, the tarball can be extracted.
  echo "tar -C \"$SOURCE_DIR\" -xvzf \"$SOURCE_DIR/$NAME.tar.gz\""
  tar -C "$SOURCE_DIR" -xvzf "$SOURCE_DIR/$NAME.tar.gz"
}

# redirect output to 'secondrun.log':
exec 3>&1 4>&2
trap 'exec 2>&4 1>&3' 0 1 2 3
exec 1>/boot/secondrun.log 2>&1

CURRENT_USER=$( whoami )
echo "START secondrun.sh as user: ${CURRENT_USER}"
# the following variables should be set by firstrun.sh
HOME_NET=COPY_HOME_NET_HERE
USE_LATEST_ELK=COPY_USE_LATEST_ELK_HERE
ELK_REPO_VERSION=COPY_ELK_REPO_VERSION_HERE

# update the system and install needed packages
echo "updating the system"
waitForApt
sudo apt update --allow-releaseinfo-change # bookworn introduced an issue with the release files being not valid
waitForApt
sudo apt full-upgrade -y
# do it again, because it seems to fix the bookworm release file issues
sudo apt update --allow-releaseinfo-change # bookworn introduced an issue with the release files being not valid
waitForApt
sudo apt full-upgrade -y
# do it again, because it seems to fix the bookworm release file issues
sudo apt update --allow-releaseinfo-change # bookworn introduced an issue with the release files being not valid
waitForApt
sudo apt full-upgrade -y

# increase swap file size
sudo dphys-swapfile swapoff
sudo sed -i "s/^CONF_SWAPSIZE=.*/CONF_SWAPSIZE=2048/" /etc/dphys-swapfile
sudo dphys-swapfile setup
sudo dphys-swapfile swapon

# just follow the guide on https://suricata.readthedocs.io/en/latest/install.html to install suricata

# install suricata all dependencies
echo "installing suricata and all dependencies"
waitForApt
sudo apt install -y suricata
#make sure suricata is not running
sudo systemctl stop suricata

# update rules
sudo suricata-update
# add a cron job to update the rules daily
#write out current crontab
# shellcheck disable=SC2024 # we want to run crontab for sudo
sudo crontab -l > tmp_crontab
#echo new cronjob into cron file
echo "3 3 * * * suricata-update" >> tmp_crontab
#install new cron file
sudo crontab tmp_crontab
sudo rm tmp_crontab

#configure suricata
#set HOME_NET. Note we use | as delimiter for sed, because HOME_NET has / for subnet notation inside
sudo sed -i "s|^\([^#]*\)HOME_NET:.*|\1HOME_NET: \"${HOME_NET}\"|" /etc/suricata/suricata.yaml
#adjust ring buffer settings for better capture performance
#sudo sed -i "s|^\([^#]*\)#*use-mmap.*|\1use-mmap: yes|" /etc/suricata/suricata.yaml
#sudo sed -i "s|^\([^#]*\)#*mmap-locked.*|\1mmap-locked: yes|" /etc/suricata/suricata.yaml
sudo sed -i "s|^\([^#]*\)#*ring-size.*|\1ring-size: 30000|" /etc/suricata/suricata.yaml

# set the default-rule-path to /var/lib/suricata/rules/suricata.rules
sudo sed -i "s|^default-rule-path:.*|default-rule-path: /var/lib/suricata/rules/|" /etc/suricata/suricata.yaml

#now enable some free sources, you can get a list of all available free sources with
#suricata-update list-sources --free
#suricata-update list-sources --enabled

#sudo suricata-update enable-source oisf/trafficid
#sudo suricata-update enable-source sslbl/ja3-fingerprints
sudo suricata-update enable-source et/open
sudo suricata-update enable-source ptresearch/attackdetection
#sudo suricata-update enable-source sslbl/ssl-fp-blacklist
#sudo suricata-update enable-source tgreen/hunting
sudo suricata-update enable-source etnetera/aggressive
# to save space, rotate suricata logs daily and keep only one copy
sudo sed -i "s/^\(.*\)rotate .*/\1rotate 1\n\1daily/g" /etc/logrotate.d/suricata

# start suricata
sudo systemctl start suricata.service

# Setup ELK stack
# follow https://www.elastic.co/guide/en/elasticsearch/reference/current/deb.html
################# DEB WAY ###################
if [[ ${USE_LATEST_ELK} == true ]] ; then
  wget https://www.elastic.co/downloads/elasticsearch -O elasticsearch.html
  ELK_VERSION=$( sed -n 's/^.*Version: <\/strong>\([^<]*\).*$/\1/p' elasticsearch.html )
  ELK_REPO_VERSION=$( echo "${ELK_VERSION}" | grep -o "^[^\.]" )
fi
# Download and install the public signing key
wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo gpg --dearmor -o /usr/share/keyrings/elasticsearch-keyring.gpg
# install apt-transport-https
waitForApt
sudo apt install apt-transport-https
# add the ELK repo to apt
echo "deb [signed-by=/usr/share/keyrings/elasticsearch-keyring.gpg] https://artifacts.elastic.co/packages/${ELK_REPO_VERSION}.x/apt stable main" | sudo tee "/etc/apt/sources.list.d/elastic-${ELK_REPO_VERSION}.x.list"
waitForApt
sudo apt update
sudo apt install -y elasticsearch kibana logstash
# limit elasticsearch heap size
echo "-Xms256m" | sudo tee /etc/elasticsearch/jvm.options.d/suricatapi.options
echo "-Xmx256m" | sudo tee -a /etc/elasticsearch/jvm.options.d/suricatapi.options
# WARNING: You are running with Java 19. To make full use of MMapDirectory, please pass '--enable-preview' to the Java command line.
echo "--enable-preview" | sudo tee -a /etc/elasticsearch/jvm.options.d/suricatapi.options
# change discovery to single-node
sudo sed -i "s/\(# For more information, consult the discovery and cluster formation module documentation.\)/\1\n#\ndiscovery.type: single-node/" /etc/elasticsearch/elasticsearch.yml
# uncomment cluster.initial_master_nodes: if not already commented
sudo sed -i "/^[^#]*cluster.initial_master_nodes:/s/^/#/g" /etc/elasticsearch/elasticsearch.yml
# disable security features for elasticsearch
sudo sed -i "s/^xpack.security.enabled:.*/xpack.security.enabled: false/g" /etc/elasticsearch/elasticsearch.yml
#sudo sed -i "s/^xpack.security.enrollment.enabled:.*/xpack.security.enrollment.enabled: false/g" /etc/elasticsearch/elasticsearch.yml
#sudo sed -i '/^.*xpack.security.http.ssl.*/{:a;n;/^.*enabled: .*/!ba;s#^.*enabled:.*#  enabled: false#}' /etc/elasticsearch/elasticsearch.yml
#sudo sed -i '/^.*xpack.security.transport.ssl.*/{:a;n;/^.*enabled: .*/!ba;s#^.*enabled:.*#  enabled: false#}' /etc/elasticsearch/elasticsearch.yml

# start elasticsearch
sudo systemctl start elasticsearch.service
# to proceed we need to reset the passwords for the elastic user
cd /usr/share/elasticsearch/bin || exit
#ES_PWD=$( sudo ./elasticsearch-reset-password --auto --batch -u elastic | sed -n "s/New value: \(.*\)/\1/p" )
# stop elasticsearch again
sudo systemctl stop elasticsearch.service
# during boot, elasticsearch might need a bit more time to start on the raspberry pi
sudo sed -i "s/^.*TimeoutStartSec=.*/TimeoutStartSec=180/" /usr/lib/systemd/system/elasticsearch.service
# sometimes elasticsearch crashes and needs to be restarted
sudo sed -i "/^.*ExecStart=.*/a Restart=on-failure\nRestartSec=60s" /usr/lib/systemd/system/elasticsearch.service

#copy configs for logstash
sudo cp /boot/10-suricata.conf /etc/logstash/conf.d/
#update logstash plugins
sudo /usr/share/logstash/bin/logstash-plugin update
#configure kibana to be accessible from remote machines
sudo sed -i "s/.*server.host: .*/server.host: 0.0.0.0/g" /etc/kibana/kibana.yml
# because of th elimited ressources of the raspberry pi, we have to ensure the start order of the services
# the start order should be: elasticsearch, logstash, kibana
sudo sed -i "/^Description=logstash.*/a Requires=elasticsearch.service\nAfter=elasticsearch.service" /usr/lib/systemd/system/logstash.service
sudo sed -i "s/^After=network-online.target.*/Requires=logstash.service\nAfter=logstash.service/g" /usr/lib/systemd/system/kibana.service

# TODO what was the ES_PWD needed for?
# TODO
# limit also logstash and kibana heap size

# reload and enable the new services
sudo systemctl daemon-reload
sudo systemctl enable elasticsearch.service
sudo systemctl enable kibana.service
sudo systemctl enable logstash.service

# start the ELK stack to do some configuration
sudo systemctl start elasticsearch.service
sudo systemctl start logstash.service
sudo systemctl start kibana.service

# wait until elasticsearch has fully started up
until curl --output /dev/null --silent --head --fail http://127.0.0.0:9200; do
  echo ["$(date +%T)"] waiting for elasticsearch to be available ...
  sleep 10
done
# the index lifecycle policy has to be imported into elasticsearch
curl --silent -X PUT -H 'Content-Type: application/json' http://127.0.0.0:9200/_ilm/policy/suricatapi-index-policy -d@/boot/suricatapi-index-policy.json
# the index template has to be imported into elasticsearch
curl --silent -X PUT -H 'Content-Type: application/json' http://127.0.0.0:9200/_index_template/suricatapi-index-template -d@/boot/suricatapi-index-template.json

# wait until kibana has started up
until curl --output /dev/null --silent --head --fail http://127.0.0.0:5601/app/home/; do
  echo ["$(date +%T)"] waiting for kibana to be available ...
  sleep 10
done
echo ["$(date +%T)"] kibana is available
sleep 30
# import the SuricataPi dashboards and related objects into kibana
# kibana starts in a degraded state, so it takes some time until the import is successful
RETRY_COUNT=0
while [ $RETRY_COUNT -le 10 ] ; do
  SUCCESS=$( curl --silent -X POST http://127.0.0.0:5601/api/saved_objects/_import?overwrite=true -H 'kbn-xsrf: true' --form file=@/boot/SuricataPi.ndjson | grep -Po '(?<="success":)\w+?[^,]*' )
  [[ ${SUCCESS} != "true" ]] || break
  RETRY_COUNT=$(( RETRY_COUNT + 1 ))
  echo ["$(date +%T)"] waiting for kibana to accept the import of saved objects ...
  sleep 10
done

#clean up
echo "remove autoinstalled packages" 
waitForApt
echo "sudo apt -y autoremove"
sudo apt -y autoremove

echo "add run /boot/thirdrun.sh command to cmdline.txt file for next reboot"
sudo sed -i '$s|$| systemd.run=/boot/thirdrun.sh systemd.run_success_action=reboot systemd.unit=kernel-command-line.target\n|' /boot/cmdline.txt

#disable the service that started this script
sudo systemctl disable secondrun.service
echo "DONE secondrun.sh, rebooting the system"

sleep 2
sudo reboot
