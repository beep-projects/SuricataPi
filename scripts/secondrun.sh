#!/bin/bash
#
# Copyright (c) 2021, The beep-projects contributors
# this file originated from https://github.com/beep-projects
# Do not remove the lines above.
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see https://www.gnu.org/licenses/
#
# This file is inspired by the firstrun.sh, generated by the Raspberry Pi Imager https://www.raspberrypi.org/software/
#
# This file will be called after the network has been configured by firstrun.sh
# It updates the system, installs motioneye and configures all attached USB cameras
# It also sets up telegram.bot as command interface and activates people detection using OpenCV for the camera images
# This script downloads a lot of stuff, so it will take a while to run
# For a full description see https://github.com/beep-projects/suricata/readme.md
#


#######################################
# Checks if any user is holding one of the various lock files used by apt
# and waits until they become available. 
# Warning, you might get stuck forever in here
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function waitForApt() {
  while sudo fuser /var/{lib/{dpkg,apt/lists},cache/apt/archives}/lock >/dev/null 2>&1; do
   echo ["$(date +%T)"] waiting for access to apt lock files ...
   sleep 1
  done
}

#######################################
# Checks if internet can be accessed
# and waits until it becomes available. 
# Warning, you might get stuck forever in here
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function waitForInternet() {
  until nc -zw1 google.com 443 >/dev/null 2>&1;  do
    #newer Raspberry Pi OS versions do not have nc preinstalled, but wget is still there
    if wget -q --spider http://google.com; then
      break # we are online
    else
      #we are still offline
      echo ["$(date +%T)"] waiting for internet access ...
      sleep 1
    fi
  done
}

# redirect output to 'secondrun.log':
exec 3>&1 4>&2
trap 'exec 2>&4 1>&3' 0 1 2 3
exec 1>/boot/secondrun.log 2>&1

echo "START secondrun.sh"
# the following variables should be set by firstrun.sh
BOT_TOKEN=COPY_BOT_TOKEN_HERE
HOME_NET=COPY_HOME_NET_HERE
MAXMIND_ACCOUNT_ID=COPY_MAXMIND_ACCOUNT_ID_HERE
MAXMIND_LICENSE_KEY=COPY_MAXMIND_LICENSE_KEY_HERE

ENABLE_RASPAP=false

# internet connectivity is required for installing required packages and updating the system
waitForInternet

# first we setup telegram, so we can send status messages to the user
echo "installing utilities missing in Raspberry OS, but needed by this script"
waitForApt
echo "I am now setting up the telegram communication"
# get latest telegram.bot from https://github.com/beep-projects/telegram.bot
wget https://github.com/beep-projects/telegram.bot/releases/latest/download/telegram.bot
chmod 755 telegram.bot
sudo ./telegram.bot --install

#echo "configuring telegram bot"
#echo "telegram.bot --get_updates --bottoken ${BOT_TOKEN}"
# for this call to be successfull, there must be one new message in the bot chat, not older than 24h
#UPDATEJSON=$( telegram.bot --get_updates --bottoken ${BOT_TOKEN} )
#echo "${UPDATEJSON}"
#get the information for the condocambot.conf
#LAST_UPDATE_ID=$( echo "${UPDATEJSON}" | jq '.result | .[0].update_id' )
# get the client_id for sending the messages to the created telegram bot
#UPDATE_TYPE="message"
#if [[ $( echo "${UPDATEJSON}" | jq '.result | .[0].message' ) = "null" ]]; then
#  UPDATE_TYPE="my_chat_member"
#fi

#CHAT_ID=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.chat.id" )
# note, the condocambot is not very picky, the sender of the first message it sees, will be the owner
#ADMIN_ID=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.id" )
#ADMIN_IS_BOT=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.is_bot" )
#ADMIN_FIRST_NAME=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.first_name" )
#ADMIN_LANGUAGE_CODE=$( echo "${UPDATEJSON}" | jq ".result | .[0].${UPDATE_TYPE}.from.language_code" )

#telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --success --text "telegram.bot is installed successfully, continuing to install the rest of the system."

# now we want to update the system and install packages
echo "updating the system"
waitForApt
sudo apt update
waitForApt
sudo apt full-upgrade -y
# fail2ban is added to add some security to the system. Remove it, if you don't like it
waitForApt
echo "sudo apt install -y fail2ban"
sudo apt install -y fail2ban

# increase swap file size
sudo dphys-swapfile swapoff
sudo sed -i "s/^CONF_SWAPSIZE=.*/CONF_SWAPSIZE=2048/" /etc/dphys-swapfile
sudo dphys-swapfile setup
sudo dphys-swapfile swapon

# write the condocambot.conf file
#echo
#echo "write the condocambot.conf file"
#echo "BOT_TOKEN=${BOT_TOKEN}" | sudo tee "${CONDOCAMBOT_CONF}" #this call creates the file, the others append to it
#echo "LAST_UPDATE_ID=${LAST_UPDATE_ID}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "CHAT_ID=${CHAT_ID}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_ID=${ADMIN_ID}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_IS_BOT=${ADMIN_IS_BOT}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_FIRST_NAME=${ADMIN_FIRST_NAME}" | sudo tee -a "${CONDOCAMBOT_CONF}"
#echo "ADMIN_LANGUAGE_CODE=${ADMIN_LANGUAGE_CODE}" | sudo tee -a "${CONDOCAMBOT_CONF}"
# make sure that the condocambot.sh is using the created conf file
#sudo sed -i "s/^CONF_FILE=.*/CONF_FILE=${CONDOCAMBOT_CONF//\//\\/}/" /boot/files/condocambot.sh
#sudo sed -i "s/^CONDOCAM_IMAGE_FOLDER=.*/CONDOCAM_IMAGE_FOLDER=${CONDOCAM_IMAGE_FOLDER//\//\\/}/" /boot/files/condocambot.sh

#telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --success --text "system is apt updated, next step is to install motion and motionEye"

# just follow the guide on https://suricata.readthedocs.io/en/latest/install.html to install suricata

# install suricata all dependencies
echo "installing suricata and all dependencies"
waitForApt
sudo apt install -y suricata
#make sure suricata is not running
sudo systemctl stop suricata

# update rules
sudo suricata-update
# add a cron job to update the rules daily
#write out current crontab
# shellcheck disable=SC2024 # we want to run crontab for sudo
sudo crontab -l > tmp_crontab
#echo new cronjob into cron file
echo "3 3 * * * suricata-update" >> tmp_crontab
#install new cron file
sudo crontab tmp_crontab
sudo rm tmp_crontab

#configure suricata
#set HOME_NET. Note we use | as delimiter for sed, because HOME_NET has / for subnet notation inside
sudo sed -i "s|^\([^#]*\)HOME_NET:.*|\1HOME_NET: \"\[${HOME_NET}\]\"|" /etc/suricata/suricata.yaml

#set the default-rule-path to /var/lib/suricata/rules/suricata.rules
sudo sed -i "s|^default-rule-path:.*|default-rule-path: /var/lib/suricata/rules/|" /etc/suricata/suricata.yaml

#now enable some free sources, you can get a list of all available free sources with
#suricata-update list-sources --free
#suricata-update list-sources --enabled

#sudo suricata-update enable-source oisf/trafficid
#sudo suricata-update enable-source sslbl/ja3-fingerprints
sudo suricata-update enable-source et/open
sudo suricata-update enable-source ptresearch/attackdetection
#sudo suricata-update enable-source sslbl/ssl-fp-blacklist
#sudo suricata-update enable-source tgreen/hunting
sudo suricata-update enable-source etnetera/aggressive

#start suricata
sudo systemctl start suricata

# Setup ELK stack
# first install java
sudo apt install -y default-jre
#sudo mkdir /usr/share/elasticsearch
#cd /usr/share/elasticsearch
#sudo wget https://packages.elastic.co/GPG-KEY-elasticsearch
#sudo apt install -y elasticsearch
# second install elasticsearch
#wget https://www.elastic.co/downloads/elasticsearch
#ES_JSON=$( grep -o '__NEXT_DATA__.*</script>' elasticsearch  | sed 's/\(__NEXT_DATA__.*json">\|<\/script>\)//g' | jq '[.. |."package"? | select(. != null)][0][] | select(.title == "Linux aarch64") | {url, hash_url}' )
#ES_URL=$( echo "${ES_JSON}" | jq -r ".url" )
#ES_HASH_URL=$( echo "${ES_JSON}" | jq -r ".hash_url" )

#ES_TARGZ=$(basename "${ES_URL}")
#ES_TARGZ_HASH=$(basename "${ES_HASH_URL}")
#ES="${ES_TARGZ//-linux-aarch64.tar.gz/}"
#if [ -d "${ES}" ]; then
#  echo "${ES} directory found. Skipping download."
#elif [ -f "${ES_TARGZ}" ]; then
#  echo "${ES_TARGZ} file found. Skipping download."
#else
#  echo "downloading Elasticsearch package from server. please wait ..."
#  rm   "${ES_TARGZ}.downloading"
#  wget "${ES_URL}" -O "${ES_TARGZ}.downloading"
#  mv   "${ES_TARGZ}.downloading" "${ES_TARGZ}"#
#
#  echo "downloading hash file for package from server. please wait ..."
#  rm "${ES_TARGZ_HASH}"
#  wget "${ES_HASH_URL}"

#  echo "checking hash value of package file"
#  HASH_OK=$( sha512sum -c "${ES_TARGZ_HASH}" | grep "${ES_TARGZ}: OK" )
#  if [ -z "${HASH_OK}" ]; then
#    echo "hash does not match, aborting"
#    exit
#  else
#    echo "hash is ok"
#  fi
#fi

#echo "extract the Elasticsearch package"
#if [ -d "${ES}" ]; then
#  echo "directory found, skip the extract"
#else
#  echo "extracting package. please wait a few minutes ..."
#  echo "tar -zxvf ${ES_TARGZ}"
#  tar -zxvf "${ES_TARGZ}"
#fi

######## get GeoIP ipdate #####################
#sudo wget https://github.com/maxmind/geoipupdate/releases/latest -O geoipupdate.html
#GEOIPUPDATE_VERSION=$( sed -n 's/^.*<h1 [^>]*>\([^<]*\)<\/h1>.*$/\1/p' geoipupdate.html )
#GEOIPUPDATE_DEB="geoipupdate_${GEOIPUPDATE_VERSION}_linux_arm64.deb"
#GEOIPUPDATE_URL="https://github.com/maxmind/geoipupdate/releases/latest/download/${GEOIPUPDATE_DEB}"
#sudo wget "${GEOIPUPDATE_URL}"
#sudo dpkg -i "${GEOIPUPDATE_DEB}"
#configure geoipupdate
#TODO remove this
#MAXMIND_ACCOUNT_ID="813423"
#MAXMIND_LICENSE_KEY="C7iq41CkdoW2R0KV"
#sudo sed -i "s/^AccountID YOUR_ACCOUNT_ID_HERE.*/AccountID ${MAXMIND_ACCOUNT_ID}/" /etc/GeoIP.conf
#sudo sed -i "s/^LicenseKey YOUR_LICENSE_KEY_HERE.*/LicenseKey ${MAXMIND_LICENSE_KEY}/" /etc/GeoIP.conf

# add a cron job to update the geoip dbs regularily
# write out current crontab
# shellcheck disable=SC2024 # we want to run crontab for sudo
#sudo crontab -l > tmp_crontab
#echo new cronjob into cron file
#echo "46 13 * * 0,4 /usr/bin/geoipupdate" >> tmp_crontab
#install new cron file
#sudo crontab tmp_crontab
#sudo rm tmp_crontab

################# DEB WAY ###################
wget https://www.elastic.co/downloads/elasticsearch -O elasticsearch.html

ELK_VERSION=$( sed -n 's/^.*Version: <\/strong>\([^<]*\).*$/\1/p' elasticsearch.html )
ELK_REPO_VERSION=$( echo "${ELK_VERSION}" | grep -o "^[^\.]" )
#Download and install the public signing key
wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo gpg --dearmor -o /usr/share/keyrings/elasticsearch-keyring.gpg
#install the apt-transport-https
waitForApt
sudo apt install apt-transport-https
#add the ELK repo to apt
echo "deb [signed-by=/usr/share/keyrings/elasticsearch-keyring.gpg] https://artifacts.elastic.co/packages/${ELK_REPO_VERSION}.x/apt stable main" | sudo tee "/etc/apt/sources.list.d/elastic-${ELK_REPO_VERSION}.x.list"
waitForApt
sudo apt update
sudo apt install -y elasticsearch kibana logstash
# limit elasticsearch heap size
echo "-Xms256m" | sudo tee /etc/elasticsearch/jvm.options.d/suricatapi.options
echo "-Xmx256m" | sudo tee -a /etc/elasticsearch/jvm.options.d/suricatapi.options
# WARNING: You are running with Java 19. To make full use of MMapDirectory, please pass '--enable-preview' to the Java command line.
echo "--enable-preview" | sudo tee -a /etc/elasticsearch/jvm.options.d/suricatapi.options
# TODO
# limit also logstash and kibana heap size
# change discovery to single-node
sudo sed -i "s/\(# For more information, consult the discovery and cluster formation module documentation.\)/\1\n#\ndiscovery.type: single-node/" /etc/elasticsearch/elasticsearch.yml
# uncomment cluster.initial_master_nodes: if not already commented
sudo sed -i "/^[^#]*cluster.initial_master_nodes:/s/^/#/g" /etc/elasticsearch/elasticsearch.yml
# start elasticsearch
sudo systemctl start elasticsearch.service
# to proceed we need to reset the passwords for the elastic user
cd /usr/share/elasticsearch/bin
ES_PWD=$( sudo ./elasticsearch-reset-password --auto --batch -u elastic | sed -n "s/New value: \(.*\)/\1/p" )
# stop elasticsearch again
sudo systemctl stop elasticsearch.service

# sudo ./elasticsearch-setup-passwords auto

# (Optional) Open a new terminal and verify that you can connect to your Elasticsearch cluster by making an authenticated call. Enter the password for the elastic user when prompted:
# curl --cacert config/certs/http_ca.crt -u elastic https://localhost:9200
# enroll kibana using detached mode
# bin/kibana-setup --enrollment-token <enrollment-token>

#disable the service that started this script
#sudo systemctl disable secondrun.service
#echo "BREAK in secondrun.sh, rebooting the system"
#sleep 2
#sudo reboot

#copy configs for logstash
sudo cp /boot/10-suricata.conf /etc/logstash/conf.d/
#update logstash plugins
sudo /usr/share/logstash/bin/logstash-plugin update
#configure kibana to be accessible from remote machines
sudo sed -i "s/.*server.host: .*/server.host: 0.0.0.0/g" /etc/kibana/kibana.yml
# because of th elimited ressources of the raspberry pi, we have to ensure the start order of the services
# the start order should be: elasticsearch, logstash, kibana
sudo sed -i "/^Description=logstash.*/a Requires=elasticsearch.service\nAfter=elasticsearch.service" /usr/lib/systemd/system/logstash.service
sudo sed -i "s/^After=network-online.target.*/Requires=logstash.service\nAfter=logstash.service/g" /usr/lib/systemd/system/kibana.service

# TODO what was the ES_PWD needed for?
# TODO disable all that security configs

#enable the new services
sudo systemctl daemon-reload
sudo systemctl enable elasticsearch.service
sudo systemctl enable kibana.service
sudo systemctl enable logstash.service

# for accessing kibana, you need to run
# sudo /usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token --scope kibana

if $ENABLE_RASPAP; then
  #install raspap
  telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --warning --text "I am installing now RaspAP, remember to secure this system after the setup is finished!"
  curl -sL https://install.raspap.com | bash -s -- --yes
fi


#telegram.bot --bottoken "${BOT_TOKEN}" --chatid "${CHAT_ID}" --success --text "All packages are installed now, I am just doing some clean up and then I will be available for you at http://${HOSTNAME}:8765"

echo "remove autoinstalled packages" 
waitForApt
echo "sudo apt -y autoremove"
sudo apt -y autoremove

echo "add run /boot/thirdrun.sh command to cmdline.txt file for next reboot"
sudo sed -i '$s|$| systemd.run=/boot/thirdrun.sh systemd.run_success_action=reboot systemd.unit=kernel-command-line.target\n|' /boot/cmdline.txt

#disable the service that started this script
sudo systemctl disable secondrun.service
echo "DONE secondrun.sh, rebooting the system"

sleep 2
sudo reboot
